# Codex Vault – Obsidian + Agents Template

This repository is a minimal, opinionated starter for integrating **AI agents**
with an **Obsidian vault** that also serves as your codebase.

Core ideas:

- Your repo _is_ an Obsidian vault.
- All AI / agent-related files live under `ai/`.
- Prompt templates for subagents live in `ai/agents/`.
- Output notes are structured and linkable so both **Obsidian** and **agents** can work with them.
- A small Node CLI (`codex-vault`) helps you manage tasks and vault structure.

Open this folder directly as an Obsidian vault, or install the npm package
and use the CLI. Actual agent execution is expected to be handled by Codex or
another orchestrator that reads the `.prompt.md` files and markdown notes.

## Installation (Node / npm)

You need Node 18+.

There are two main ways to use this:

1. As a **template repo** – clone/fork this repo and build your project inside it.
2. As an **npm CLI** – install it and run `codex-vault init` inside any existing repo.

From this repo (local dev):

```bash
npm install -g .
```

Once published to npm:

```bash
# one-off in any repo
npx codex-vault init

# or install globally
npm install -g codex-vault
codex-vault init
```

## Quick start

From the vault root:

```bash
# 0) Initialize ai/ structure (if you don't already have it)
codex-vault init

# 1) Create a task
codex-vault task create inspections-checklist-ui --title "Inspections checklist UI" --description "Build the first version of the inspections checklist page."

# 2) List tasks
codex-vault task list

# 3) See basic vault info
codex-vault info
```

This will:

- Create `ai/backlog/inspections-checklist-ui.md` with YAML frontmatter.
- Leave `ai/research/`, `ai/plans/`, etc. for your agents (e.g. Codex) to fill
  using the prompts in `ai/agents/`.

## CLI overview

All commands assume you run them from the vault root.

```bash
codex-vault init [--force]
codex-vault task create <slug> [--title TITLE] [--description DESC]
codex-vault task list
codex-vault info
```

- `init` – copy the `ai/` template (AGENTS + subagent prompts + folders) into the current repo.
- `task create` – create a backlog note under `ai/backlog/`.
- `task list` – list existing backlog tasks.
- `info` – print a quick summary of the expected vault layout.

## Agent architecture

Agents are defined by markdown prompt templates under `ai/agents/`:

- `_base.prompt.md` – shared environment + style rules.
- `research.prompt.md` – Codebase Researcher.
- `impl-plan.prompt.md` – Implementation Planner.
- `workflow-designer.prompt.md` – Workflow Designer.
- `test-writer.prompt.md` – Test Writer.
- `user-qa.prompt.md` – User QA / UX.

This repo does **not** call OpenAI directly. Instead:

- Codex (or another orchestrator) should:
  - Read `ai/AGENTS.md` and `ai/agents/*.prompt.md`.
  - Choose a subagent (e.g. Research, Impl Plan).
  - Provide relevant file snippets (backlog, PRDs, code) as context.
  - Save the agent’s markdown output into the appropriate `ai/` folder.

The Node CLI here is deliberately thin and focused on making the vault
structure easy to work with from a JS/Next.js codebase.

## Using with Codex / IDE flows (pseudo-code)

Roughly, a Codex / Node flow for running the **Research** agent for a task slug
would look like:

```ts
// 1) Read prompts and context
const basePrompt = await fs.promises.readFile("ai/agents/_base.prompt.md", "utf8");
const agentPrompt = await fs.promises.readFile("ai/agents/research.prompt.md", "utf8");
const system = `${basePrompt}\n\n---\n\n${agentPrompt}`;

const backlog = await fs.promises.readFile(`ai/backlog/${taskSlug}.md`, "utf8");

// 2) Build a user message with snippets
const user = `
TASK_SLUG: ${taskSlug}

TASK BACKLOG:
[FILE: ai/backlog/${taskSlug}.md]
"""
${backlog}
"""
`;

// 3) Call Codex / model (pseudo-API)
const result = await codex.chat({
  system,
  user,
  // ...model / options...
});

// 4) Save response into ai/research/
await fs.promises.writeFile(
  `ai/research/${taskSlug}-research.md`,
  result.content.trim() + "\n",
  "utf8"
);
```

The same pattern applies for `impl-plan`, `test-writer`, etc.: load the
corresponding `ai/agents/*.prompt.md`, feed the right snippets, then write the
markdown into `ai/`.

## Repo layout

- `ai/AGENTS.md` – high-level rules for agents working in this vault.
- `ai/agents/` – prompt templates for subagents (research, planning, tests, UX, workflows).
- `ai/backlog/` – one markdown file per task.
- `ai/research/` – research notes generated by the Research agent.
- `ai/plans/` – implementation plans, context digests, task lists, and test plans.
- `ai/workflows/` – end-to-end workflow descriptions.
- `ai/qa/` – QA / UX sessions.
- `ai/runs/` – optional execution logs.
- `docs/` – product docs, PRDs, personas, etc.

## Why this is useful / pitch

This template is meant to be:

- **A reusable AI+Obsidian workflow starter** – drop it into any repo to get
  a consistent place for AI research, plans, workflows, and QA notes.
- **Token-conscious** – agents share a base prompt and use `task_slug` +
  frontmatter conventions so orchestrators can fetch minimal, targeted context.
- **Human-friendly** – everything is plain markdown you can read and edit in Obsidian.
- **Automation-ready** – the Node CLI is thin and easy to script or extend from Next.js or other JS code.

How you might describe it on a resume / project page:

- Designed and implemented an AI-assisted engineering workflow template that
  integrates OpenAI agents with an Obsidian-powered codebase.
- Built a Node CLI (`codex-vault`) that manages AI task notes and vault structure,
  ready to be wired into Codex or other agent runtimes.
- Introduced a token-efficient context strategy using `task_slug`-based indexing
  and shared base prompts, making it easy to reuse across projects.

For a short video or demo, walk through:

1. Opening the vault in Obsidian (show `ai/` folders).
2. Creating a task with `codex-vault task create <slug>`.
3. Showing how Codex (or another agent runner) uses the prompts in `ai/agents/`
   to generate research / plans / workflows into the `ai/` folders.
4. Explaining how this pattern can be dropped into any repo (especially a Next.js app)
   to give you an “AI co-pilot” that writes and maintains your engineering notes.
